# Link
[AcWing 799. 最长连续不重复子序列](https://www.acwing.com/problem/content/801/)

# 双指针算法模板
```cpp
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) 
        j ++ ;
      // 具体问题的逻辑
}
```

# 常见问题分类
- 对于一个序列，用两个指针维护一段区间
  - 左区间和右区间的起始位置
  - 左端点和右端点移动分别是什么情况
    - 同向双指针
    - 对撞双指针
    - 快慢双指针 
- 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作

# 关键
在暴力做法中，会有不少重复计算的步骤，利用双指针记录题目中具有单调性的性质，减少重复计算，可降低其时间复杂度

# 例题分析
- 暴力法
  枚举每个区间，对每个 $i$ 和 $j$ 都遍历一遍，对每个 $i$ 和 $j$ 都`check()`一下中间的数据是否满足给定的条件。这样的时间复杂度是$O(N^2)$数据稍微大点就会超时。
  - 双重循环 
  ```cpp
  for (int i = 0; i < n; i++)
        for (int j = 0; j <= i; j++)
            if (check(v, j, i)) //检查 i 和 j 之间是否有重复的数字
                res = max(res, i - j + 1);
  ```
  - `check()`函数
  ```cpp
  bool check(vector<int>& v, int l, int r)
  {
      for (int i = l + 1; i <= r ; i++)
          for (int j = l; j < i; j++)
              if (v[i] == v[j])
                  return false;
      return true;
  }
  ```
- 双指针法 $1$
  仔细考虑暴力法就会发现，暴力法在解题时有很多地方是重复计算了 ( $i$ 指针在 $j$ 指针的后面，$i$ 是遍历的整个数组的，$j$ 是遍历 $0$ 到 $i$ 的)：
  
  比如 $j = 0，i = 5$，此时发现 $i，j$ 是满足题解条件的；那么后面的 $j = 1～5，i = 5$ 就不用计算了，因为**不重复序列的子序列一定不重复，肯定满足条件**
  
  这便是此题目中的单调性
  
  这样就是 $i$ 和 $j$ 指针都是从前移到后，也就是计算$2n$次。时间复杂度是$O(2N)$。
  
  ```cpp
  for (int i = 0, j = 0; i < n; i++)
  {
      while (j <= i)
          if (check(v, j, i))
          {
              // 该区间不重复
              res = max(res, i - j + 1); //记录答案
              break; //跳过子区间的枚举
          }
          else j ++;
  }
  ```
  
- 双指针法 $2$（最终版）
  但是上面代码还是超时，为什么呢？因为`check()`函数写的不好，循环太多，直接是暴力计算找重复数字的，显然不好。

  所以引出一个新的`check()`方法：**对于寻找是否有重复数字，一般用hash**，没人用暴力。所以用hash就可以计算。
  
  用一个辅助数组`S`保存原数组`V`每个元素存在的次数，和`hash`类似。
  比如说 `V = {1, 2, 2, 3, 5 }`。那 `S` 就是 `{0,1,2,1,0,1 }`
  
  `S[V[i]]`表示的是`V1[i]`的个数。
  此处我们用`S`数组只保存 $j$ 和 $i$ 指针之间的数的个数。

  ### 算法思路
   如果 $j = 0，i = 5$ ，此时检查 `S` 数组元素都是 $<=1$ 的。那下一步的情况就是 $i$ 。$i$ 之后将`S` 数组更新，只需要检查`S[v[i]]` 元素是不是比 $1$ 大即可，因为随着 $i$ 的递增，`S`数组中变化的只有 `S[v[i]]` 元素
   
  **如果检查`S[v[i]]`元素发现该元素比 $1$ 大。那说明 $j$ 指针和 $i$ 指针之间有某个元素出现了两次**。所以 $i$ 指针保持不动， $j$ 指针往后移动
  - 注意： $j$ 指针不可能往前移动的，上次 $j$ 指针往后移动就是因为 $j$ 和 $i$ 之间有重复元素，这一往前移动肯定有重复元素
  
  $j$ 指针往后移动之前需要先更新`S`数组，即进行 `S[v[j]]–-` 操作。然后 $j$ 指针再往后移动。移动之后只需要检查 $i$ 指针对应的`S[v[i]]`元素是否 $>1$ 即可
  
  因为 $j$ 指针移动之后只有两种情况
  - 1.重复元素刚好没了，则`S[v[i]]`肯定$=1$
  - 2.重复元素还在，那`S[v1[i]]==2`，需要 $j$ 继续往后移动

  等`S[v[i]]==1` 时，说明 $j$ 和 $i$ 之间已经没有重复元素了，可以更新`res`值，然后 `i ++`

  ```cpp
  for (int i = 0,j = 0; i < n; i++)
  {
      S[v[i]] ++;
      while ( S[v[i]] > 1) -- S[v[j ++]];
      res = max(res, i - j + 1);
  }
  ```
  
# Code
```cpp
#include<iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int N = 100010;

int main()
{
    int n;
    cin >> n;
    vector<int> v(n, 0);
    for (int i = 0; i < n; i++)
        cin >> v[i];

    vector<int> S(N, 0);

    int res = 0;
    for (int i = 0,j = 0; i < n; i ++)
    {
        S[v[i]] ++;
        while ( S[v[i]] > 1) -- S[v1[j ++]];
        res = max(res, i - j + 1);
    }

    cout << res;

    return 0;
}
```
