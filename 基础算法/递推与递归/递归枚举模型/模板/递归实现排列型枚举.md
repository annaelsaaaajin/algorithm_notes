# 递归实现排列型枚举
[LeetCode 46. 全排列](https://leetcode.cn/problems/permutations/)
[AcWing 94. 递归实现排列型枚举](https://www.acwing.com/problem/content/96/)

# 解题思路
### 递归边界
数全部填完
```cpp
if (u == n)
{
    ans.push_back(res);
    return;
}
```
### 子问题
答案数组中 $0～n-1$ 的位置分别填 $a_1～a_n$ 中的一个数，填了之后就不能再用了
### 恢复现场
同一层的子问题相互独立，要恢复现场
```cpp
for (int i = 0; i < n; i ++)
{
    if (used[i]) continue;
    res.push_back(nums[i]);
    used[i] = true;
    dfs(u + 1, nums);
    used[i] = false;
    res.pop_back();
}
```
### Code
```cpp
class Solution {
public:
    vector<bool> used;
    vector<int> res;
    vector<vector<int>> ans;
    int n;

    void dfs(int u, vector<int> &nums)
    {
        if (u == n)
        {
            ans.push_back(res);
            return;
        }

        for (int i = 0; i < n; i ++)
        {
            if (used[i]) continue;
            res.push_back(nums[i]);
            used[i] = true;
            dfs(u + 1, nums);
            used[i] = false;
            res.pop_back();
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        n = nums.size();
        used = vector<bool> (n, false);
        dfs(0, nums);
        return ans;
    }
};
```

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10;

int n;
int state[N];   // 0 表示还没放数，1~n表示放了哪个数
bool used[N];   // true表示用过，false表示还未用过

void dfs(int u)
{
    if (u > n)  // 边界
    {
        for (int i = 1; i <= n; i ++ ) printf("%d ", state[i]); // 打印方案
        puts("");

        return;
    }

    // 依次枚举每个分支，即当前位置可以填哪些数
    for (int i = 1; i <= n; i ++ )
        if (!used[i])
        {
            state[u] = i;
            used[i] = true;
            dfs(u + 1);

            // 恢复现场
            state[u] = 0;
            used[i] = false;
        }
}

int main()
{
    scanf("%d", &n);

    dfs(1);

    return 0;
}
```

# 如果允许重复元素呢？
[LeetCode 47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

重复元素在一个全排列中是等价的，与在原数组中的位置无关，于是开一个计数的哈希表，用一个 $i$ ，`cnt[i] --`，$cnt$ 为 $0$ 则不能用（记得恢复现场） 

```cpp
class Solution {
public:
    unordered_map<int, int> cnt;
    vector<int> res;
    vector<vector<int>> ans;
    vector<int> t; 
    int n;

    void dfs(int pos, vector<int>& nums)
    {
        if (pos == n)
        {
            ans.push_back(res);
            return;
        }

        for (int i = 0; i < nums.size(); i ++)
        {
            if (!cnt[nums[i]]) continue;
            res.push_back(nums[i]);
            cnt[nums[i]] --;
            dfs(pos + 1, nums);
            cnt[nums[i]] ++;
            res.pop_back();
        }
    }

    vector<vector<int>> permuteUnique(vector<int>& nums)
    {
        n = nums.size();
        for (auto i : nums) cnt[i] ++;
        for (auto i : cnt) t.push_back(i.first);
        nums = t;
        dfs(0, nums);
        return ans;
    }
};
```
- yxc
```

```